# 第7章 虚拟机类加载机制

## 7.1 概述
- Java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验，转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这个过程被称作虚拟机的类加载机制。
 
## 7.2 类加载的时机
- 一个类型从被加载到虚拟机内存中开始，到卸载初内存为止，它的整个生命周期将会经历加载、验证、准备、解析、初始化、使用和卸载七个阶段，
其中验证、准备、解析三个部分统称为连接。这七个阶段的发生顺序如图7-1所示。
![类的生命周期](./pictures/类的生命周期.png)  
- <div style="text-align: center;">图7-1 类的生命周期 </div>
- 对于初始化阶段，《Java虚拟机规范》严格规定了有且只有六种情况必须对类进行“初始化”：
  - 1）遇到new、getstatic、putstatic或invokestatic这四条字节码指令时，如果类型没有进行过初始化，则需要先触发其初始化阶段。能够生成这四条指令的典型Java代码场景有：
    - 使用new关键字进行实例化对象的时候。
    - 读取或设置一个类型的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）的时候。
    - 调用一个类型的静态方法的时候。
  - 2）使用java.lang.reflect包的方法对类型进行反射调用的时候，如果类型没有进行过初始化，则需要先触发其初始化。
  - 3）当初始化类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。
  - 4）当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个类。
  - 5）当使用JDK7新加入的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果为REF_getStatic、REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial四种类型的方法句柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化。
  - 6）当一个接口中定义了JDK8新加入的默认方法（被default关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。
- 以上六种场景中的行为称为对一个类型进行主动引用。除此之外，所有引用类型的方式都不会出发初始化，称为被动引用。以下三点说明何为被动引用。
  - 1）通过子类引用父类的静态字段，不会导致子类初始化。
  - 2）通过数组定义来引用类，不会触发类的初始化。
  - 3）常量在编译阶段会存入调用类的常量池中，本质上没有直接引用到定义常量的类，因此不会触发定义常量类的初始化。  
  
## 7.3 类的加载过程
### 7.3.1 加载
- 在加载阶段，Java虚拟机需要完成以下三件事情：
  - 1）通过一个类的全限定名来获取定义此类的二进制字节流。
  - 2）讲这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
  - 3）在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。
- 对于数组类而言，情况就有所不同，数组类本身不通过类的加载器创建，它是由Java虚拟机直接在内存中动态构造出来的。但数组类与类加载仍然有很密切的关系，
因为数组类的元素类型最终还是要靠类加载来完成加载，一个数组类（下面简称为C）创建的过程遵循以下规则：
  - 如果数组的组件类型是引用类型，那就递归采用本节中定义的加载过程去加载这个组件类型，数组C将被标识在加载该组件类型的类加载器的类名称空间上。
  - 如果数组的组件类型不是引用类型（例如int[]数组的组件类型为int），Java虚拟机将会把数组C标记为与引导类加载器关联。
  - 数组类的可访问性与它的组件类型的可访问性一致，如果组件类型不是引用类型，它的数组类的可访问性将默认为public，可被所有的类的接口访问到。
- 加载阶段结束后，Java虚拟机外部的二进制字节流就按照虚拟机所设定的格式存储在方法区之中了，方法区中的数据存储格式完全由虚拟机实行自定义。
类型数据妥善安置在方法区之后，会在Java堆内存中实例化一个java.lang.Class类的对象，这个对象将作为程序访问方法区中的类型数据的外部接口。
  
  