# 第5章 调优案例分析与实战

## 5.2 案例分析

### 5.2.1 大内存硬件上的程序部署策略
- 一个很久前的案例，但今天仍然具有代表性。一个15万PV/日左右的在线文档类型网站最近更新了硬件系统，
服务器的硬件为四路志强处理器、16GB物理内存，操作系统为64位CentOS 5.4，Resin作为Web服务器。
整个服务器暂时没有部署别的应用，所有硬件资源都可以提供给这访问量并不算太大的文档网站使用。
软件版本选用的是64位的JDK5，管理员启用了一个虚拟机实例，使用-Xmx和-Xms参数将Java堆大小固定在12GB。
使用一段时间后发现服务器的运行效果十分不理想，网站经常不定期出现长时间失去响应。

- 监控服务器运行状况后发现网站失去响应是由垃圾收集停顿所导致的，在该系统软硬件条件下，HotSpot虚拟机是以服务端模式运行，
默认使用的是吞吐量优先收集器，回收12GB的Java堆，一次Full GC的停顿时间就高达14秒。由于程序设计的原因，
访问文档时会把文档从磁盘提取到内存中，导致内存中出现很多文档序列化产生的大对象，这些大对象大多数在分配时就直接进入了老年代，
没有在Minor GC中被清理掉。这种情况下即使有12GB的堆，内存也会很快被消耗殆尽，由此导致每隔几分钟出现十几秒的停顿就，
令网站开发、管理员都对使用Java技术开发网站感到很失望。

- 分析此案例的情况，程序代码问题这里不延伸讨论，程序部署上的主要问题显然是过大的内存进行回收时带来的长时间的停顿。
经调查，更早之前的硬件使用的是32位操作系统，给HotSpot虚拟机只分配了1.5G的堆内存，当时用户确实感觉使用网站比较缓慢，
但还不至于发生长达十几秒的明显停顿，后来将硬件升级到64位系统、16GB内存希望能提升程序效能，却反而出现了停顿问题，
尝试过将Java堆分配的内存重新缩小到1.5GB或者2GB，这样的确可以避免长时间停顿，但是在硬件上的投资就显得非常浪费。

- 目前单体应用在较大内存的硬件上主要的部署方式有两种：
  - 1）通过一个单独的Java虚拟机实例来管理大量的Java堆内存。
  - 2）同时使用若干个Java虚拟机，建立逻辑集群利用硬件资源。

- 此案例中的管理员采用了第一种部署方式。对于用户交互性强、对停顿时间敏感、内容又较大的系统，
并不是一定要使用Shenandoah、ZGC这些明确以控制延迟为目标的垃圾收集器才能解决问题，
使用Parallel Scavenge/Old收集器，并且给Java虚拟机分配较大的堆内存也是有很多运行成功的案例的，
